# Monitoring module

Monitoring module allows to inject user specific metric and monitor processes running at the same machine.

## Metrics injection
Metric consists of 4 parameters: name, value, entity and timestamp.

| Parameter name | Type                                          | Required | Default          |
| -------------- |:---------------------------------------------:|:--------:| ----------------:|
| name           | string                                        | yes      | -                |
| value          | int/double/uint32t/string                     | yes      | -                |
| entity         | string                                        | no       | <hostname>.<PID> |
| timestamp      | chrono::time_point<std::chrono::system_clock> | no       | current time     |

Not required parameters can be omitted. They will generated automatically (see Default column).


## Processes monitoring
The running process is monitored by default. In addition any other processes running at the same machine can be monitored as well.
The following following metrics are generated for each process:
1. cputime - cumulative CPU time, "[DD-]HH:MM:SS" format.
2. etime - elapsed time since the process was started, in the form [[DD-]hh:]mm:ss.
3. pcpu - cpu utilization of the process in "##.#" format. Currently, it is the CPU time used divided by the time the process has been running (cputime/realtime ratio), expressed as a percentage.  It will not add up to 100% unless you are lucky.
4. pmem - ratio of the process's resident set size  to the physical memory on the machine, expressed as a percentage.
5. rsz - resident set size, the non-swapped physical memory that a task has used (in kiloBytes).
6. vsz - virtual memory size of the process in KiB (1024-byte units).  Device mappings are currently excluded; this is subject to change.


## Monitoring backends
Metrics are pushed over network to backends. The following backends are supported:
1. InfoLogger
2. MonALISA (via AppMon)
3. InfluxDB (via cURL)

## Configuration file
+ AppMon
  + enable - enable AppMon (MonALISA) backend
  + pathToConfig - path to AppMon configuration file
+ InfluxDB
  + enable - enable InfluxDB backend
  + hostname - server hostname
  + port - server port
  + db - name of database
+ InfoLoggerBackend
  + enable - enable InfoLogger backend
+ ProcessMonitor
  + enable - enable process monitor
  + interval - updates interval 
+ DerivedMetrics
  + maxCacheSize - maximum size of vector


## Getting started
Examples are avalibale in *example* directory.

### Injecting user specific metric
Simple example that allows to send a metric:
```C++
// create monitoring object, pass confuguration path as parameter
  std::unique_ptr<Monitoring::Core::Collector> collector(
    new Monitoring::Core::Collector("file:///home/hackathon/Monitoring/SampleConfig.ini")
  );  

  // now send an application specific metric
  // 10 is the value
  // myCrazyMetric is the name of the metric
  collector->send(10, "myCrazyMetric");
```

### Non-default entity value
Default entity value is set to <hostname>.<PID> This value can be changed by setEntity method:
```C++
  // create monitoring object, pass configuration path as parameter
  std::unique_ptr<Monitoring::Core::Collector> collector(
    new Monitoring::Core::Collector("file:///home/hackathon/Monitoring/SampleConfig.ini")
  );  

  // set user specific entity value, eg.:
  collector->setEntity("testEntity");

  // now send an application specific metric
  // 10 is the value
  // myCrazyMetric is the name of the metric
  collector->send(10, "myCrazyMetric");
```

### User-generated timestamp
By default timestamp is generated by library, but user can also set it manually.
```C++
  // create monitoring object, pass configuration path as parameter
  std::unique_ptr<Monitoring::Core::Collector> collector(
    new Monitoring::Core::Collector("file:///home/hackathon/Monitoring/SampleConfig.ini")
  );  

  // generate current timestamp
  std::chrono::time_point<std::chrono::system_clock> timestamp = std::chrono::system_clock::now();
     
  // now send an application specific metric
  // 10 is the value 
  // myCrazyMetric is the name of the metric
  collector->send(10, "myCrazyMetric", timestamp);
  
  // sleep 1 second, and send different metric with the same timestamp
  std::this_thread::sleep_for(std::chrono::seconds(1));
  collector->send(40, "myCrazyMetric", timestamp);
}
```

###  Derived metrics
Library provides functionality of calculating derived metrics: average value and rate.
```C++
// create monitoring object, pass configuration path as parameter
  std::unique_ptr<Monitoring::Core::Collector> collector(
    new Monitoring::Core::Collector("file:///home/hackathon/Monitoring/SampleConfig.ini")
  );  

  // derived metric :  rate
  collector->addDerivedMetric("myCrazyMetric1", Monitoring::Core::DerivedMetricMode::RATE);

  // now send at least two metrics to see the result
  collector->send(10, "myCrazyMetric1");
  collector->send(20, "myCrazyMetric1");
  collector->send(30, "myCrazyMetric1");
  collector->send(50, "myCrazyMetric1");
```
### Process monitoring
Library monitors current process by default but it also allows to monitor other processes running at the same machine.
  // create monitoring object, pass configuration path as parameter
```ruby
  std::unique_ptr<Monitoring::Core::Collector> collector(
    new Monitoring::Core::Collector("file:///home/hackathon/Monitoring/SampleConfig.ini")
  );  

  // add additional PID to be monitored
  collector->addMonitoredPid(1);
     
  for (;;) {
    collector->send(10, "mainThreadMetric");
    // manual monitor update
    collector->sendProcessMonitorValues();
    std::this_thread::sleep_for(std::chrono::seconds(1));
  }
```
